// qrc-zig compiles a Qt resource XML file (*.qrc) to an import file or a
// binary resource file and creates a Zig stub to load it.
package main

import (
	"bytes"
	"flag"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strconv"
	"strings"
)

const (
	DefaultVariableName string = "_resourceRcc"
	DefaultRccBinary    string = "rcc"
	DefaultGenBinary    bool   = false
	DefaultUpper        bool   = false
)

func QrcExec() error {
	// Parse arguments
	var inFile, outZig, outRcc, varName, rccPath, embedPath string
	var genBinary, upper bool

	inUsage := "Path to .qrc input file"
	outZigUsage := "(Optional) Path to .zig output file; if omitted, inferred from the input file path"
	outRccUsage := "(Optional) Path to .rcc output file; if omitted, inferred from the Zig file path"
	varNameUsage := "(Optional) Variable name for loading embedded data"
	rccUsage := "(Optional) Custom path to the Qt 'rcc' program"
	upperUsage := "(Optional) Use uppercase hex letters, defaults to false"
	genBinaryUsage := "(Optional) Generate a binary resource file, defaults to false"
	shorthandUsage := " (shorthand)"

	flag.StringVar(&inFile, "input_file", "", inUsage)
	flag.StringVar(&inFile, "i", "", inUsage+shorthandUsage)
	flag.StringVar(&outZig, "output_zig", "", outZigUsage)
	flag.StringVar(&outZig, "o", "", outZigUsage+shorthandUsage)
	flag.StringVar(&outRcc, "output_rcc", "", outRccUsage)
	flag.StringVar(&outRcc, "O", "", outRccUsage+shorthandUsage)
	flag.StringVar(&varName, "variable_name", DefaultVariableName, varNameUsage)
	flag.StringVar(&varName, "v", DefaultVariableName, varNameUsage+shorthandUsage)
	flag.StringVar(&rccPath, "rcc_path", DefaultRccBinary, rccUsage)
	flag.StringVar(&rccPath, "r", DefaultRccBinary, rccUsage+shorthandUsage)
	flag.BoolVar(&upper, "uppercase", DefaultUpper, upperUsage)
	flag.BoolVar(&upper, "u", DefaultUpper, upperUsage+shorthandUsage)
	flag.BoolVar(&genBinary, "binary", DefaultGenBinary, genBinaryUsage)
	flag.BoolVar(&genBinary, "b", DefaultGenBinary, genBinaryUsage+shorthandUsage)
	flag.Parse()

	if inFile == "" {
		flag.Usage()
		os.Exit(1)
	}

	// Check if input file exists
	if _, err := os.Stat(inFile); os.IsNotExist(err) {
		return fmt.Errorf("Input file '%s' not found\n", inFile)
	}

	// Figure out regeneration command and fill in default output names, if not specified
	generate := "qrc-zig" + " -i " + strconv.Quote(inFile)

	if outZig != "" && strings.HasSuffix(outZig, ".zig") {
		generate += " -o " + strconv.Quote(filepath.Base(outZig))
	} else {
		outZig = strings.TrimSuffix(inFile, ".qrc") + ".zig"
	}

	if outRcc != "" && strings.HasSuffix(outRcc, ".rcc") {
		// The rcc output path must be relative to the output Zig file path
		ePath, err := filepath.Rel(filepath.Dir(outZig), outRcc)
		if err != nil {
			return err
		}
		embedPath = ePath
		generate += " -O " + strconv.Quote(embedPath)
	} else {
		outRcc = strings.TrimSuffix(outZig, ".zig") + ".rcc"
	}

	if varName != DefaultVariableName {
		generate += " -v " + strconv.Quote(varName)
	}

	if upper {
		generate += " -u"
	}

	if genBinary {
		generate += " -b"
	}

	if rccPath != DefaultRccBinary {
		generate += " -r " + strconv.Quote(rccPath)
	}

	// Compile qrc to binary resource file
	rccCmd := exec.Command(rccPath, "--binary", "-o", outRcc, inFile)
	rccCmd.Stderr = os.Stderr
	rccCmd.Stdout = os.Stdout
	errRcc := rccCmd.Run()
	if errRcc != nil {
		return errRcc
	}

	rccToStr := strings.Builder{}
	rccToStr.WriteString(`// Generated by libqt6zig qrc. To update this file, edit the .qrc file in
// Qt Creator/Designer and then run the 'qrc-zig' command below.
//
// ` + generate + `

const qt6 = @import("libqt6zig");

`)

	// Create methods to register and unregister the resource
	defMethods := `pub fn init() bool {
    return qt6.qresource.RegisterResource2(&` + varName + `[0]);
}

pub fn deinit() bool {
    return qt6.qresource.UnregisterResource2(&` + varName + `[0]);
}
`

	if !genBinary {
		// Convert the binary resource file to string data
		rccBinary, err := os.ReadFile(outRcc)
		if err != nil {
			return err
		}

		rccToStr.WriteString(defMethods + "\n")

		rccReader := bytes.NewReader(rccBinary)

		if err = xxd(rccReader, &rccToStr, varName, upper); err != nil {
			return err
		}

		if err = os.Remove(outRcc); err != nil {
			return err
		}
	} else {
		// Embed the binary resource file
		rccToStr.WriteString(`const ` + varName + ` = @embedFile("` + outRcc + `");
`)
		rccToStr.WriteString("\n" + defMethods)
	}

	if writeErr := os.WriteFile(outZig, []byte(rccToStr.String()), 0644); writeErr != nil {
		return fmt.Errorf("Error writing to '%s': %w", outZig, writeErr)
	}

	return nil
}

func main() {
	err := QrcExec()
	if err != nil {
		fmt.Fprintf(os.Stderr, "qrc-zig: %s\n", err.Error())
		os.Exit(1)
	}
}
